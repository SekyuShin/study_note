# 분해합
Created at : 2025-09-19 22:50
[baekjoon_2231](https://www.acmicpc.net/problem/2231)
### 조건
- 시간 : 2
- 메모리 : 192
### 문제
어떤 자연수 N이 있을 때, 그 자연수 N의 분해합은 N과 N을 이루는 각 자리수의 합을 의미한다. 어떤 자연수 M의 분해합이 N인 경우, M을 N의 생성자라 한다. 예를 들어, 245의 분해합은 256(=245+2+4+5)이 된다. 따라서 245는 256의 생성자가 된다. 물론, 어떤 자연수의 경우에는 생성자가 없을 수도 있다. 반대로, 생성자가 여러 개인 자연수도 있을 수 있다.

자연수 N이 주어졌을 때, N의 가장 작은 생성자를 구해내는 프로그램을 작성하시오.
### 입력
첫째 줄에 자연수 N(1 ≤ N ≤ 1,000,000)이 주어진다.
### 출력
첫째 줄에 답을 출력한다. 생성자가 없는 경우에는 0을 출력한다.
### 제한
- 
### 예제
- 입력
```
216
```
- 출력
```
198
``` 

### 풀이
- My solution
```python
import sys
N = sys.stdin.readline().strip()

start_i = 0
if int(N) >= 100:
    start_i = int(N)-100

ret = 0
for i in range(start_i,int(N)):
    str_i = str(i)
    tmp_ret = i
    for j in range(len(str_i)):
        tmp_ret += int(str_i[j])
    if tmp_ret == int(N):
        ret = i
        break

print(ret)
```

- Answer
```python

```

- Analyze
	- 처음 풀이는 그냥 무식하게 차수를 낮추어서 그 부분부터 계산을 진행했다. (ex. N=1920이면, 100부터 분해합을 구하기)
	- 다만, N의 단위가 100만이기에 큰 수면 오랜 시간이 걸린다. (10만 단위라면, 1만 단위부터 N까지 구하므로 최대 99만번 반복한다. (약 1초))
	- 때문에 좀 더 효과적인 방법이 없을까 생각하다. 분해합을 구하는 공식에서 분해합들에 대해 집중해 보았다. 예를 들어 100의 자리수에서 가장 큰 수인 999면 999 + 9 + 9 + 9로 100의 자리에선 27 이상의 분해합이 나올 수 없다.
	- 같은 원리로 최대 100만 즉 9`*`7 = 63으로 생성자와 분해합에서 63이상의 차이가 나올 수 없다라는 가정을 하고 문제를 풀어 시간을 획기적으로 줄여보았다.
	- ![[Pasted image 20250920194721.png]]
### 알고리즘 분류
- 브루트포스 알고리즘