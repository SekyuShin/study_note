# 큐 2
Created at : 2025-10-10 22:25
[baekjoon_18258](https://www.acmicpc.net/problem/18258)
### 조건
- 시간 : 1
- 메모리 : 512
### 문제
정수를 저장하는 큐를 구현한 다음, 입력으로 주어지는 명령을 처리하는 프로그램을 작성하시오.

명령은 총 여섯 가지이다.

- push X: 정수 X를 큐에 넣는 연산이다.
- pop: 큐에서 가장 앞에 있는 정수를 빼고, 그 수를 출력한다. 만약 큐에 들어있는 정수가 없는 경우에는 -1을 출력한다.
- size: 큐에 들어있는 정수의 개수를 출력한다.
- empty: 큐가 비어있으면 1, 아니면 0을 출력한다.
- front: 큐의 가장 앞에 있는 정수를 출력한다. 만약 큐에 들어있는 정수가 없는 경우에는 -1을 출력한다.
- back: 큐의 가장 뒤에 있는 정수를 출력한다. 만약 큐에 들어있는 정수가 없는 경우에는 -1을 출력한다.
### 입력
첫째 줄에 주어지는 명령의 수 N (1 ≤ N ≤ 2,000,000)이 주어진다. 둘째 줄부터 N개의 줄에는 명령이 하나씩 주어진다. 주어지는 정수는 1보다 크거나 같고, 100,000보다 작거나 같다. 문제에 나와있지 않은 명령이 주어지는 경우는 없다.
### 출력
출력해야하는 명령이 주어질 때마다, 한 줄에 하나씩 출력한다.
### 제한
- 
### 예제
- 입력
```
15
push 1
push 2
front
back
size
empty
pop
pop
pop
size
empty
pop
push 3
empty
front
```
- 출력
```
1
2
2
0
1
2
-1
0
1
-1
0
3
``` 

### 풀이
- My solution (시간 초과)
```python
import sys

class Queue :
    def __init__(self):
        self.queue_arr = []

    def push(self, a):
        self.queue_arr.append(a)

    def pop(self):
        ret = -1
        if self.queue_arr:
            # ret = self.queue_arr.pop(0)
            ret = self.queue_arr[0]
            self.queue_arr = self.queue_arr[1:]
        return ret
    
    def size(self):
        return len(self.queue_arr)
    
    def empty(self):
        return 1 if not self.queue_arr else 0
    
    def front(self):
        ret = -1
        if self.queue_arr:
            ret = self.queue_arr[0]
        return ret
    
    def back(self):
        ret = -1
        if self.queue_arr:
            ret = self.queue_arr[-1]
        return ret
    

N = int(sys.stdin.readline().strip())
queue = Queue()
for _ in range(N):
    tmp_str = sys.stdin.readline().strip()

    if "push" in tmp_str:
        queue.push(tmp_str.split()[1])
    elif "pop" in tmp_str:
        print(queue.pop())
    elif "size" in tmp_str:
        print(queue.size())
    elif "empty" in tmp_str:
        print(queue.empty())
    elif "front" in tmp_str:
        print(queue.front())
    elif "back" in tmp_str:
        print(queue.back())
```
- Answer (1552ms)
```python
import sys
from collections import deque
 
input = sys.stdin.readline
 
N = int(input())
queue = deque()
 
for _ in range(N):
    order = input().strip()
 
    if 'push' in order:
        X = order.split()[1]
        queue.append(int(X))
    elif order == 'pop':
        if queue:
            print(queue.popleft())
        else:
            print(-1)
    elif order == 'size':
        print(len(queue))
    elif order == 'empty':
        if queue:
            print(0)
        else:
            print(1)
    elif order == 'front':
        if queue:
            print(queue[0])
        else:
            print(-1)
    elif order == 'back':
        if queue:
            print(queue[-1])
        else:
            print(-1)
```

- Analyze
	- 여러 방면으로 해보았지만, 전부 시간 초과가 나왔다. 
	- Answer를 보니 deque를 사용해서 푼다. deque를 사용하는 장점으로는 양방향 queue로 양쪽에서 요소를 추가하거나 삭제 할 수 있고, 또한 리스트는 O(N)의 시간 복잡도를 가지지만, deque는 O(1)의 시간 복잡도를 가지기에 훨씬 빠르고 append / remove / push / pop의 연산이 자주 일어나는 알고리즘에서 강세를 보인다고 한다.
### 알고리즘 분류
- 자료구조
- 큐