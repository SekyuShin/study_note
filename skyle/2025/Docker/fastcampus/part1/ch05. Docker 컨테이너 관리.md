ch05. Docker 컨테이너 관리
Created at : 2025-02-28 22:16
# Clip1 컨테이너 격리 기술

### Docker container start
```
docker run -it --rm --name=mycontainer ubuntu:14.04 bash	
```
- <font color="#00b050">컨테이너 격리 기술이란</font>
	- <font color="#00b050">컨테이너는 기본적으로 이미지 스냅샷이다.</font>
	- <font color="#00b050">도커 이미지는 여러 개의 레이어로 구성되어 있으며, 각 레이어는 파일 시스템의 변경 사항을 포함합니다. 이미지는 패키지, 라이브러리, 소스 코드, 환경 변수 등을 포함하고 있다.</font>
	- <font color="#00b050">ReadOnly 상태의 이미지: 도커 이미지는 기본적으로 읽기 전용이다. 컨테이너가 생성될 때 이 이미지를 기반으로 새로운 레이어가 추가된다.</font>
	- <font color="#00b050">컨테이너 레이어: 컨테이너가 생성될 때, 이미지의 레이어를 복제 (snapshot) 하여 /var/lib/docker/overlay2와 같은 위치에 저장된다. 이때 컨테이너 레이어(Process Layer)가 추가되어 변경 사항을 기록한다. 이 레이어는 읽기-쓰기 가능한 상태로 변경됨</font>
	- <font color="#00b050">UFS (Union File System): 도커는 여러 레이어를 결합할 수 있도록 Union File System을 사용한다. 이를 통해 여러 레이어의 파일 시스템을 하나의 가상 파일 시스템으로 통합하여 관리할 수 있다.</font>
![[Pasted image 20250228221812.png]]
- 컨테이너를 통해 확인 가능한 격리 기술
	- 아래의 기술들을 사용하여 컨테이너 내부에 독립된 프로세스 환경이 만들어 진다.
- chroot & pivot_root (최상의 ) 
	- 최상의 경로의 root file system을 만드는 기술
	- 독립적인 File System을 보장받는다.
```
ls
	bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys...
```
- pivot_root & mount namespcase (/etc/hosts)
	- 컨테이너 내에서 호스트 OS의 /etc/hosts 파일이 마운트
	- 이 파일은 네임 서비스에 사용됨 (hostname, result.conf...)
```
df -h
	Filesystem Size Used Avail Use% Mounted on 
	overlay 100G 7.0G 94G 7% / 
	...
	/dev/sdb1 100G 7.0G 94G 7% /etc/hosts
	...
```
- UTS namespace : Host Name 할당 기술, 컨테이너 ID가 host 명이 된다.
```
hostname
	7a3e9b12fb1b
```
- PID/IPC namespace : 해당 Container의 OS가 PID 1번을 갖는다.
```
ps -ef
	UID PID PPID C STIME TTY TIME CMD 
	root 1 0 0 05:28 pts/0 00:00:00 bash 
	root 19 1 0 05:31 pts/0 00:00:00 ps -ef
```
- Network namespace
```
ifconfig
	eth0 Link encap:Ethernet HWaddr 02:42:ac:11:00:03
		 inet addr:172.17.0.3 Bcast:172.17.255.255 Mask:255.255.0.0
```

### 컨테이너 격리 기술

| 격리 기술             | Description                                            |
| ----------------- | ------------------------------------------------------ |
| chroot            | 프로세스의 루트 디렉토리를 변경, 격리하여 가상의 루트 디렉터리를 생성                |
| pivot_root        | 루트 파일시스템 자체를 바꿔, 컨테이너가 전용 루트 파일시스템을 가지도록 함 (chroot 보완) |
| Mount namespace   | namespace 내에 파일 시스템 트리를 구성                             |
| UTS namespace     | 컨테이너에 대한 hostname 격리를 수행하여 고유한 hostname 보유 가능          |
| PID namespace     | PID와 프로세스를 분리(systemd(OS PID 1번)와 분리 )                 |
| Network namespace | 네트워크 리소스(IP, Port, route table, ethernet, ...) 할당      |
| IPC namespace     | 전용의 process table 보유                                   |
- `lsns` : 전체적인 namespace의 목록 확인 명령어

### docker 컨테이너 lifecycle
- docker 컨테이너는<span style="background:#d3f8b6"> docker create</span> 명령을 통해 <span style="background:#d3f8b6">image의 snapshot</span>으로 <span style="background:#d3f8b6">/var/lib/docker</span> 영역에 생성된다.
- <span style="background:#d3f8b6">docker start</span> 명령은 읽고 쓰기가 가능한 <span style="background:#d3f8b6">Process영역</span> 즉, container layer를 생성하여 동적 컨테이너를 구성하게 된다. 또한,<span style="background:#d3f8b6"> docker stop</span>은 생성된 <span style="background:#d3f8b6">container layer</span>를 삭제한다.
- <span style="background:#d3f8b6">docker rm</span>은 생성된<span style="background:#d3f8b6"> snapshot을 삭제</span>하는 과정을 통해 docker container lifecycle을 알 수 있다.
![[Pasted image 20250301001553.png]]
- docker 컨테이너를 수동으로 생성해보자 → docker run = [pull] + create + start + [command] 
```
# docker create는 run과 달리 Container에 process를 올리지 않고, snapshot만 생성
docker pull ubuntu:16.04
docker images

docker create -it --name myubuntu16-1 ubuntu:16.04
docker ps –a
	CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 
	Fbdc628ebf36 Ubuntu:16.04 "/bin/bash" About a minute ago Created myubuntu16-1
	
docker start myubuntu16-1
docker attach myubuntu16-1
	[root@fbdc628ebf36 /]#

# 한번에 한다면?
docker run -it --name=myubuntu16-2 ubuntu:16.04 bash
```
### Docker 컨테이너는 어떤 모습일까?
- docker 컨테이너는 1) Process다. 2) image snapshot이다.
- 위 두가지 실체를 확인해 보기위해 간단한 시스템 컨테이너를 실행해 본다.
```
cd ~/LABs/ch05$
docker run -it --name=mycontainer ubuntu:14.04 bash 
	echo 'fastcampus!' > mycontainer.txt 
	cat mycontainer.txt 
		fastcampus!
```
- 다른 터미널을 열어 linux ps 명령으로 해당 컨테이너를 확인한다.
- <span style="background:#d3f8b6">컨테이너는 동적 프로세스와 같다</span>. (ps 명령어로 해당 docker run이 조회가 된다.)
![[Pasted image 20250303004106.png]]
- <span style="background:#d3f8b6">컨테이너 내부에서 생성된 정보는 container layer + snapshot 영역에 저장된다.</span>
- /var/lib/docker/overlay2/(container name)/merged에 해당 컨테이너의 root 영역이 있다.
- 해당 영역이 snapshot 영역이다.
```
# 
sudo su -
find /var/lib/docker -name mycontainer.txt
	/var/lib/docker/overlay2/6a712b...7385de/diff/mycontainer.txt 
	/var/lib/docker/overlay2/6a712b...7385de/merged/mycontainer.txt
cd /var/lib/docker/overlay2/6a712b...7385de/merged

# mycontainer.txt 확인
ls
	... root sbin sys usr bin etc lib media mycontainer.txt proc run srv tmp var
```
![[Pasted image 20250303004536.png]]

# Clip2 컨테이너 관리를 위한 docker CLI (1)

### Docker 컨테이너 CLI (Command Line Interface)
![[Pasted image 20250301002508.png]]

### docker [container] run  [option] docker_image [command]
- 컨테이너 명령 테스트를 위한 이미지를 만들어 보자.
```
cd ~/fastcampus/ch05
vi runapp.js
	const http = require('http');
	const server = http.createServer().listen(6060);
	server.on('request', (req, res) => { console.log('Your request arrived.');
	res.write("HostName: " + process.env.HOSTNAME + "\n");
	res.end();
	});
	server.on('connection', (socket) => { console.log("Your Connected.");
	});

vi Dockerfile
	FROM node:20-alpine3.17 
	RUN apk add --no-cache tini curl 
	WORKDIR /app COPY runapp.js .
	EXPOSE 6060
	ENTRYPOINT ["/sbin/tini", "--"] 
	CMD ["node", "runapp.js"]

docker build -t noderun:1.0 .
docker images | grep noderun
docker image history noderun:1.0
docker run -itd -p 6060:6060 --name=node-run -h node-run noderun:1.0
docker ps | grep node
curl localhost:6060

```

| 옵션                                     | 설명                                                                                       |
| -------------------------------------- | ---------------------------------------------------------------------------------------- |
| -i, --interactive                      | 대화식 모드 열기                                                                                |
| -t                                     | TTY(Teletypewriter) 할당                                                                   |
| -d, --detach=true                      | 백그라운드에서 컨테이너 실행하고 컨테이너 ID 등록                                                             |
| --name                                 | 실행되는 컨테이너에 이름 부여 (미 지정 시 자동으로 부여됨: 딕셔너리 워드 랜덤 선택)                                        |
| --rm                                   | 컨테이너 종료 시 자동으로 컨테이너 제거                                                                   |
| --restart                              | 컨테이너 종료 시 적용할 재시작 정책 지정.                       ([noon-failure \| on-failure:횟수n always]) |
| --env, -e                              | 컨테이너의 환경변수 지정   (--env-file은 여러 환경 변수를 파일로 생성하여 지정하는 방법)                                 |
| -v, --volume=호스트경로:컨테이너경로              | 호스트 경로와 컨테이너 경로의 공유 볼륨 설정. (Bind mount 라고 함)                                             |
| -h                                     | 컨테이너의 호스트명 지정 (미 지정 시 컨테이너 ID가 호스트명으로 등록)                                                |
| -p [Host 포트]:[Container 포트], --publish | 호스트 포트와 컨테이너 포트 연결                                                                       |
| -P, --publish-all=[true\|false]        | 컨테이너 내부의 노출된(expose) 포트를 호스트 임의의 포트에 게시                                                  |
| --workdir, -w                          | 컨테이너 내부의 작업 경로(디렉터리)                                                                     |

### docker top | port | stats
- docker top, 컨테이너에서 실행 중인 프로세스 조회
```
docker top node-run
```
- docker port, 컨테이너에 매핑된 포트 조회
```
docker port node-run
```
- docker stats, 컨테이너 리소스 사용 통계에 대한 실시간 스트림 출력 (스트림 통계 비활성화, --no-stream)
```
docker stats node-run
```

### docker stats와 유사한 통계, Metric 정보를 수집하는 cadvisor
- cadvisor 컨테이너 생성 (google에서 제공하고 관리하는 오픈 소스 컨테이너 모니터링 도구)
```
docker run \
--restart=always \
--volume=/:/rootfs:ro \
--volume=/var/run:/var/run:rw \
--volume=/sys/fs/cgroup:/sys/fs/cgroup:ro \
--volume=/var/lib/docker/:/var/lib/docker:ro \
--volume=/dev/disk/:/dev/disk:ro \
--publish=9559:8080 \
--detach=true \
--name=cadvisor \
--privileged \
--device=/dev/kmsg \
gcr.io/cadvisor/cadvisor:latest
```
 
### docker logs
- 컨테이너에서 발생하는 stdout (표준출력), stderr (표준에러) 출력
```
while true; do curl 192.168.56.101:6060; sleep 3; done

# 다른 터미널에서
docker logs -f node-run
	Your Connected.
	Your request arrived.
	Your Connected.
	Your request arrived.
	...

# 출력되는 로그 양이 큰 경우, disk full error의 원인이 되기도 함
docker info | grep -i log
	Logging Driver: json-file 
	Log: awslogs fluentd gcplogs gelf journald json-file local logentries 
	splunk syslog
sudo ls -l

# log 지우기
sudo truncate -s 0
sudo ls -l

# 컨테이너에서 발생하는 log size 제한
sudo vi /etc/docker/daemon.json 
	{ "insecure-registries": ["192.168.56.101:5000"],
		"log-driver": "json-file", 
		"log-opts": { 
			"max-size": "30m", 
			"max-file": "10"
		} 
	}
sudo systemctl restart docker.service
sudo systemctl status docker.service
또는,
docker run -itd -p 6062:6060 --name=node-run2 \ 
-h node-run --log-driver json-file --log-opt max-size=30m --log-opt max-file=10 \ 
noderun:1.0

# MySQL 컨테이너 로그 확인
docker run -itd --name=mydb mysql:5.7-debian
docker ps -a
docker logs mydb

```

### docker [container] inspect
- 컨테이너 내부 구조 정보 확인
```
docker container inspect node-run
```

### docker cp | restart
- 컨테이너내의 source 수정 적용
```
vi runapp.js
	const http = require('http');
	const server = http.createServer().listen(6060);
	server.on('request', (req, res) => { 
		console.log('fastcampus request arrived.');
		res.write("HostName: " + process.env.HOSTNAME + "\n");
		res.end();
	});
	server.on('connection', (socket) => { 
		console.log("fastcampus Connected.");
	});
docker cp runapp.js node-run:/app/runapp.js
docker restart node-run
docker ps | grep node
```
- Container 내의 파일을 Host로 복사
```
docker container cp <Container명 또는 ID>:<Container 내의 파일 경로> <Host 디렉터리 경로> 
docker container cp <Host 파일> <Container명 또는 ID>:<Container 내의 파일 경로>
```
- test Container의 /etc/passwd 파일을 Host의 /tmp/etc에 복사
```
docker run –itd --name=my_container centos
docker cp my_container:/var/log/ /home/kevin/centos_log/
```
- Host의 현재 디렉터리에 있는 local.txt 파일을 text Container의 /tmp/local.txt로 복사
```
touch local.txt
docker cp ./local.txt my_container:/tmp/local.txt
docker exec -it my_container ls /tmp
```
- webserver container 의 /etc/nginx/nginx.conf를 HostOS 경로에 복사
```
docker run -d -p 7777:80 --name=webserver nginx:1.25.0-alpine 
docker cp webserver:/etc/nginx/nginx.conf /home/kevin/nginx.conf
```
- nginx 웹서버 구성을 reverse Proxy 구성으로 변경하고,
```
docker cp nginx.conf webserver:/etc/nginx/nginx.conf
docker restart webserver
```

# Clip3 컨테이너 관리를 위한 docker CLI (2)

### docker stop | start | pause | unpause
- cadvisor 컨테이너 생성
```
while true; do curl 192.168.56.101:6060; sleep 3; done
```
- 다른 터미널2
```
docker events
```
- 다른 터미널3, docker start는 SIGTERM 보냄
```
docker stop node-run 
docker ps –a 
docker start node-run
```
- linux의 freezer cgroup을 통해 일시 중지
```
docker pause node-run
docker unpause node-run
docker ps –a
```
### docker kill
- 컨테이너 상태 조정
```
while true; do curl 192.168.56.101:6060; sleep 3; done
```
- 다른 터미널2, docker의 실시간 이벤트 출력 (마지막 1000개 이벤트만 기록)
```
docker events # --until time(h|m|s), --since date1 date2, --filter “key=value”)
```
- 다른 터미널3
```
docker exec -it node-run sh
(세션 종료)
```
- 다른 터미널4, docker start는 SIGKILL 보냄
```
docker kill node-run
docker ps -a
```
### docker exit code

| #   | 이름                    | 의미                                                      |
| --- | --------------------- | ------------------------------------------------------- |
| O   | 의도적으로 중지              | 컨테이너가 자동으로 중지되었음을 나타내기 위해 개발자가 사용                       |
| 1   | 신청 오류                 | 애플리케이션 오류 또는 이미지 사양의 잘못된 참조로 인해 컨테이너가 중지 됨              |
| 125 | 컨테이너 실행 실패 오류         | docker run 명령이 성공적으로 실행되지 않음                            |
| 126 | 명령 호출 오류              | 이미지 사양에 지정된 명령을 호출할 수 없음                                |
| 127 | 파일 또는 디렉터리를 찾을 수 없음   | 이미지 사양에 지정된 파일 또는 디렉터리를 찾을 수 없음                         |
| 128 | 종료 시 잘못된 인수가 사용되었습니다. | 잘못된 종료 코드로 종료가 실행 됨(유효한 코드는 0-255 사이의 정수임).             |
| 134 | 비정상 종료(SIGABRT)       | 컨테이너가 abort() 함수를 사용하여 자체적으로 중단됨                        |
| 137 | 즉시 종료(SIGKILL)        | 컨테이너가 SIGKILL 신호를 통해 운영 체제에 의해 즉시 종료 됨                  |
| 139 | 분할 결함(SIGSEGV)        | 컨테이너가 할당되지 않은 메모리에 액세스하려고 시도하여 종료 됨                     |
| 143 | 단계적 종료(SIGTERM)       | 컨테이너가 곧 종료될 것이라는 경고를 받은 후 종료됨 (graceful)                |
| 255 | 종료 상태가 범위를 벗어남        | 컨테이너가 종료되어 허용 가능한 범위를 벗어난 종료 코드를 반환. 오류의 원인을 알 수 없음을 의미 |
### docker attach | exec
- docker attach, 실행 중인 컨테이너에 stdout, stdin, stderr 스트림 연결 (<font color="#00b050">출력용</font>)
```
docker run -d --name top-container ubuntu:22.04 /usr/bin/top -b
ocker attach top-container
```
- docker exec, 실행 중인 컨테이너에 명령 실행
```
docker run -itd --name=my_container alpine sh
docker exec -d my_container touch /tmp/exec_test
docker exec -it my_container sh
	ls
	cd /tmp
	ls
docker exec -it -w /tmp my_container pwd
```
### docker diff
- docker diff, 실행 중인 컨테이너에 변경사항 출력
```
docker exec -it node-run sh
	adduser kevin
docker diff node-run
```
![[Pasted image 20250301005921.png]]

### docker commit
- docker commit, 실행 중인 컨테이너의 변경사항을 포함한 새로운 이미지 생성
```
docker commit node-run noderun:2.0
docker images | grep noderun
docker run -itd --name=node-run3 -p 6063:6060 noderun:2.0
while true; do curl 192.168.56.101:6063; sleep 1; done
docker logs -f node-run3
```
### docker export | import
- docker export, 실행 중인 컨테이너의 파일 시스템을 tar archive로 내보내기(backup, migration) 
- export는 image save와 다르게 이미지의 layer에 대한 내용은 포함되지 않고, 
- export로 추출한 컨테이너 내의 정보는 하나의 레이어로 통합된다.
```
docker ps
docker export node-run > node-run.tar
ls
tar tvf node-run.tar
sudo scp node-run.tar hostos2:/home/skyle

# hostos2
cat node-run.tar | docker import - node-run:3.0
docker images | grep node
docker run -itd --name=node-run3 -p 6064:6060 noderun:3.0
	docker: Error response from daemon: No command specified.
```
- 위 에러는 export를 통해 만들어진 이미지는 단순히 컨테이너의 파일시스템을 아카이빙해서 만든 이미지이기 때문에 컨테이너 run 후 실행할 명령(CMD)이 요구된다
- <font color="#00b050">import는 daemon을 가져오지 못한다.</font>
- [solution] import 시 CMD를 추가하는 방법과 Dockerfile에 import된 이미지와 CMD를 추가하여 생성한다.
```
docker rmi node-run:3.0
docker import --change 'CMD ["node", "/app/runapp.js"]' node-run.tar node-run:3.0
docker images | grep node
docker run -itd --name=node-run3 -p 6064:6060 node-run:3.0
docker ps -a | grep node
curl localhost:6064
```
- 두 번째 방법은 import된 이미지를 Dockerfile에 CMD를 추가하여 새로 빌드한다.
```
cat node-run.tar | docker import - node-run:4.0
vi Dockerfile_noderun4
	FROM node-run:4.0 
	CMD ["node", "/app/runapp.js"]
docker build -t node-run:5.0 -f Dockerfile_noderun4 .
docker images | grep node
docker run -itd --name=node-run5 -p 6065:6060 node-run:5.0
docker ps | grep node-run5
curl localhost:6065
```