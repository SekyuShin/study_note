ch06.Docker 네트워크
Created at : 2025-03-03 21:44
# Clip1 컨테이너 네트워크
### docker network
- Docker network는 커널의 네트워크 스택의 하위로 상위에는 네트워크 드라이버를 생성한다. 즉, <span style="background:#d3f8b6">docker network = Linux network </span>와 같다.
- Docker network 아키텍처는<span style="background:#d3f8b6"> CNM</span>(Container Networking Model)이라고 하는 인터페이스 집합 위에 구축한다. OS 및 인프라에 구애 받지 않으므로 인프라 스택에 관계없이 애플리케이션이 동일한 환경을 가질 수 있다.
	- <font color="#00b050">CNM은 구현 모델 방식이고, 실제로는 Lib Network 구현하였다.</font>
- 리눅스 네트워킹 빌딩 블록: 리눅스 브리지, 네트워크 네임스페이스, veth pair 및 iptables가 포함. 이 조합은 복잡한 네트워크 정책을 위한 전달 규칙, 네트워크 분할 및 관리 도구를 제공한다.
	
- Linux bridge
	- 리눅스 브리지는 커널 내부의 물리적 스위치를 가상으로 구현한 OSI Layer 2 Device 다.
	- 트래픽을 검사하여 동적으로 학습되는 MAC 주소를 기반으로 트래픽을 전달.
	- bridge network의 기본 대역?
		1) 172.{17-31}.0.0/16(655367H) 
		2) 192.168.{0-240}.0/20(40967H)
![[Pasted image 20250303214914.png]]
- Network namespace
	- 커널에 격리된 네트워크 스택으로 자체 인터페이스, 라우트 및 방화벽 규칙을 보유
		- 컨테이너와 리눅스의 보안적인 측면으로, 컨테이너를 격리하는데 사용
		- 네트워크 네임스페이스는 도커 네트워크를 통해 구성된 경우가 아니면 동일한 호스트의 두 컨테이너가 서로 통신하거나 호스트 자체와 통신할 수 없음을 보장
		- 일반적으로 CNM(Container Network Model) 네트워크 드라이버는 각 컨테이너에 대해 별도의 네임스페이스를 구현
		- [참고] https://github.com/moby/libnetwork/blob/master/docs/design.md

- CNM (Container Network Model)
![[Pasted image 20250303214949.png]]
- CNM, libnetwork
![[Pasted image 20250303215001.png]]
- veth (virtual ethernet device)
![[Pasted image 20250303215018.png]]

- Bridge network (docker0)와 연결되어 있는 컨테이너들 (veth)
```
sudo apt install bridge-utils 
brctl show
```
![[Pasted image 20250310232559.png]]

- 172.17.0.0 (docker0)
```
docker run -it -d --name=fast-ubuntu ubuntu:14.04
docker exec -it fast-ubuntu route
```
![[Pasted image 20250310233154.png]]

- eth0를 보면 docker network의 대역폭을 가진다. (172.17.0.5)
- 이 eth0는 brctl show로 보이는 veth와 pair를 가진다.
```
docker exec -it fast-ubuntu ip addr
```
![[Pasted image 20250310233253.png]]

```
ifconfig
```

- container IP 주소 보는 법
```
docker network inspect bridge
```
![[Pasted image 20250310234043.png]]
- Container IP 주소 보는 법 2
```
docker inspect -f "{{ .NetworkSettings.IPAddress }}" fast-ubuntu
```
![[Pasted image 20250310234104.png]]

- Container IP 주소 보는 법 3
```
docker inspect fast-ubuntu | grep IPAddress
```
![[Pasted image 20250310234213.png]]
- Container MAC Address 보는 법
```
docker inspect fast-ubuntu | grep Mac
```

- veth(virtual ethernet device)
	- 두 네트워크 네임스페이스 사이의 연결선으로 동작하는 리눅스 네트워킹 인터페이스
	- veth는 각 네임스페이스에 단일 인터페이스가 있는 전이중 링크(full duplex link)
	- 한 인터페이스의 트래픽을 다른 인터페이스로 전달
	- 도커 네트워크를 만들 때 도커 네트워크 드라이버는 veth를 사용하여 네임스페이스 간에 명시적인 연결을 제공
	- 컨테이너가 도커 네트워크에 연결되면 veth의 한쪽 끝은 컨테이너 내부에 배치되며, (일반적으로 ethN 인터페이스로 표시) 다른 쪽은 도커 네트워크에 연결된다.
### docker network, veth
- Container의 네트워크(eth0)는 vethxxxxxxx의 숫자보다 하나 작은 값을 가진다.
-  (? 아래 예시는 8/8로 같다?)
```
brctl show 
```
![[Pasted image 20250310235844.png]]

```
docker exec fast-ubuntu ip addr show eth0
```
![[Pasted image 20250311000357.png]]

```
sudo su -
	cat /sys/class/net/veth151c896/ifindex
	8
docker exec -it fast-ubuntu bash
	cat /sys/class/net/eth0/iflink
	8
```

- 포트포워딩 = NAT?
```
sudo iptables -t nat -L -n
```
![[Pasted image 20250311000932.png]]

### docker network

| 옵션                                                                    | 설명                                                                     |
| --------------------------------------------------------------------- | ---------------------------------------------------------------------- |
| --add-host=[Host명:IP Address]                                         | Container의 /etc/hosts에 Host명과 IP Address를 설정                           |
| --dns=[IP Address]                                                    | DNS 서버의 IP Address를 설정 (/etc/resolv.conf) (168.126.63.1~3 / 8.8.8.8)   |
| --mac-address=[MAC Address]                                           | Container의 MAC Address 설정                                              |
| --expose=[포트 번호]                                                      | Container 내부에서 Host로 노출할 포트 번호 지정                                      |
| --net=[bridge \| none \| host]                                        | Container의 네트워크 설정 (bridge = docker0)                                  |
| -h, --hostname="Host명"                                                | Container의 Host명 설정(default, container ID가 호스트명)                       |
| -P, --publish-all=[true \| false]                                     | Container 내부의 노출된 포트를 호스트 임의의(32768~) 포트를 호스트와 연결(명시적)                 |
| -p [Host 포트 번호]:[Container 포트 번호] --publish published=5000, target=80 | Host와 Container의 포트를 매핑(암시적)                                           |
| --link=[container:container_id]                                       | 동일 Host의 다른 Container에서 액세스 시 이름 설정 → IP 가 아닌 container의 이름을 이용해 통신 가능 |
- container DNS 서버 설정
```
docker run -it --dns=8.8.8.8 centos bash 
	cat /etc/resolv.conf nameserver 8.8.8.8
```
- container MAC Address 설정
```
docker run -d --mac-address="92:d0:c6:0a:29:33" centos:7
docker inspect --format="{{ .Config.MacAddress }}" c268f1
```
- Host명과 IP Address 설정
```
docker container run -it --add-host=fastcampus.co.kr:192.168.0.100 centos:7 bash 
	cat /etc/hosts
```

- docker-proxy? kernel이 아닌 사용자 환경에서 수행되기 때문에 kernel과 상관없이 host가 받은 패킷을 그대로 container의 port로 전달. port를 외부로 노출하도록 설정하게 되면, docker host에는 docker-proxy 라는 프로세스가 자동으로 생성
```
docker run -d -P --name=myweb --expose=40001 nginx:1.25.0
docker port myweb
```

```
docker ps | grep myweb
```

```
sudo netstat -nlp | grep 32773
```

```
ps -ef | grep 75516
```
### docker network, overlay
- Overlay network는 서로 다른 Host(node)에서 서비스되는 컨테이너를 네트워크로 연결하는데 사용 되고, 이런 네트워크 생성을 위해 overlay network driver 를 사용 한다.
- 네트워크로 연결된 여러 Docker Host 안에 있는 Docker Daemon 간의 통신을 관리하는 가상 네트워크다.
- 컨테이너는 overlay network의 서브넷에 해당하는 IP 대역을 할당 받고, 받은 IP를 통해 상호간의 내부 통신을 수행한다.
- 따라서, overlay network에 포함되어 있는 모든 컨테이너들은 서로 다른 Docker Host에 있는 컨테이너와 같은 서버에 있는 것처럼 통신이 가능해 진다.
- Docker swarm을 통해 구현할 수 있다. (ch.11)
- `docker network inspect {network-ID}` 를 통해 조회 가능

![[Pasted image 20250303215915.png]]

# Clip2 사용자 정의 네트워크
### 사용자 정의 docker network
- docker는 기본적으로 Host OS와 bridge 연결을 하며, --net 옵션을 통해 네트워크 설정 가능
- docker network create로 "사용자 정의 bridge network" 생성
- 사용자 정의 네트워크에 연결하면 Container는 Container의 이름이나 IP 주소로 서로 통신 가능
- Overlay network(docker swarm)나 커스텀 플러그인 사용 시 multi-host 연결 가능

| 값                              | 설명                                                            |
| ------------------------------ | ------------------------------------------------------------- |
| bridge                         | bridge 접속 (default: docker0 – 172.17.0.0/16) 사용 : 172.17.0.2~ |
| none                           | 네트워크에 접속하지 않음. 무지정 (격리용)                                      |
| container:[container_name\|id] | 다른 Container 의 네트워크를 사용 (container:ub_test)                   |
| host                           | Container Host OS의 네트워크를 사용                                   |
| macvlan                        | 물리적 네트워크에 컨테이너 mac 주소를 통한 직접적 연결 구현 시 사용                      |
| NETWORK(사용자 정의 network name)   | 사용자 정의 네트워크 사용                                                |

### docker network, "host"
- nginx 이미지에 노출된 포트 80번을 호스트 포트 80번에 연결 호스트 IP를 이용하여 서비스.
```
docker run -d --name=nginx_host --net=host nginx:1.25.0
sudo netstat -nlp | grep 80
```

```
curl localhost:80
```

-  -p 옵션으로 포트를 연결한 경우에는 docker-proxy를 이용했지만, 출력된 결과를 보면 호스트 운영체제에 직접 PID를 할당 받아 서비스하는 것을 알 수 있고, Docker0를 사용하지 않는다.
```
ps -ef | grep 8967
```
- 따라서 컨테이너에는<span style="background:#d3f8b6"> 별도의 IP가 부여</span>되지 않는다.
```
docker inspect nginx_host | grep IPAddress
```
### docker network create
```
docker network create [-d(--driver) bridge] mynet
docker network ls
```

```
route
docker network inspect b04e3178d1f9
ifconfig
```

```
T2] docker run --net=mynet -it --name=net-check1 ubuntu:14.04 bash
	ifconfig
	route
```
![[Pasted image 20250311233216.png]]
```
T3] docker run --net=mynet -it --name=net-check2 ubuntu:14.04 bash
T1] brctl show
```
![[Pasted image 20250311233229.png]]

```
docker network inspect mynet # "Subnet": "172.18.0.0/16"	
```
- 사용자 정의 네트워크 구성을 통해 <span style="background:#d3f8b6">컨테이너 이름으로 통신</span>이 가능, Docker DNS에 의한 Service Discovery(서비스 검색) 기능을 사용할 수 있다.
```
T2] docker run --net=mynet -it --name=net-check1 ubuntu:14.04 bash
	ping -c 3 net-check2
```

```
T3] docker run --net=mynet -it --name=net-check2 ubuntu:14.04 bash
	ping -c 3 net-check1
```
![[Pasted image 20250311233425.png]]

- 사용자 정의 네트워크 구성을 통해 특정 IP 대역 지정도 가능하다.
![[Pasted image 20250303221315.png]]
```
docker network create \
--driver bridge \
--subnet 172.30.1.0/24 \
--ip-range 172.30.1.0/24 \
--gateway 172.30.1.1 \
vswitch-net
```

```
docker network ls
```

```
docker run --net=vswitch-net -itd --name=net1 ubuntu:14.04
docker run --net=vswitch-net -itd --name=net2 --ip 172.30.1.100 ubuntu:14.04
```
- 생성된 Bridge network 정보를 inspect를 통해 확인
```
docker network inspect vswitch-net
```
- 사용자 정의 네트워크 구성을 통해 특정 IP 대역 지정도 가능하다.
```
docker inspect net1 | grep IPAddress
docker inspect net2 | grep IPAddress

brctl show
route
ip route

docker exec net1 ip addr
```

### docker network topology
![[Pasted image 20250303221558.png]]

### Docker network connect | disconnect
- 실행 중인 컨테이너에 새로운 네트워크 대역의 docker network를 연결해 본다.
```
docker run -it --name=add-net ubuntu:14.04 bash
	ifconfig
```

- 다른 터미널
```
docker ps
```

```
docker network create --driver=bridge fc-net2
docker netwrok ls
route
```

```
ifconfig
```

- 실행 중인 컨테이너에 새로운 네트워크 대역의 docker network를 연결해 본다.
```
docker network connect fc-net2 add-net
	ifconfig
```

```
docker network inspect fc-net2
docker network rm fc-net2
```

```
docker network disconnect fc-net2 add-net
	ifconfig
```

![[Pasted image 20250303221933.png]]

```
docker network create --driver=bridge back-net 
docker network create --driver=bridge front-net
docker run --name=my-web -itd --net=front-net ubuntu:14.04
docker run --name=my-was -itd --net=back-net ubuntu:14.04
docker run --name=my-db -itd --net=back-net ubuntu:14.04
docker network connect back-net my-web
docker exec my-web route
docker exec my-was route
docker exec my-db route
docker network inspect front-net # my-web
docker network inspect back-net # my-web / my-was / my-db
```

```
docker exec -it my-web bash
	ping -c 1 my-was
```

```
	ping -c 1 my-db
```


```
docker exec –it my-was bash
	ping –c 1 my-web
	ping –c 1 my-db

```

```
docker network disconnect front-net my-was 
docker stop my-web my-was my-db 
docker rm my-web my-was my-db 
docker network rm back-net 
docker network rm front-net
```



# Clip3 Docker DNS


# Clip4 컨테이너 Proxy


# Clip5 [실습] Nginx를 활용한 컨테이너 Proxy


# Clip6 [실습] HAProxy를 활용한 컨테이너 Proxy



