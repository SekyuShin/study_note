 # 히스토그램에서 가장 큰 직사각형
Created at : 2025-12-25 22:17
[baekjoon_6549](https://www.acmicpc.net/problem/6549)
### 조건
- 시간 : 1
- 메모리 : 256
### 문제
히스토그램은 직사각형 여러 개가 아래쪽으로 정렬되어 있는 도형이다. 각 직사각형은 같은 너비를 가지고 있지만, 높이는 서로 다를 수도 있다. 예를 들어, 왼쪽 그림은 높이가 2, 1, 4, 5, 1, 3, 3이고 너비가 1인 직사각형으로 이루어진 히스토그램이다.

![](https://www.acmicpc.net/upload/images/histogram.png)

히스토그램에서 가장 넓이가 큰 직사각형을 구하는 프로그램을 작성하시오.
### 입력
입력은 테스트 케이스 여러 개로 이루어져 있다. 각 테스트 케이스는 한 줄로 이루어져 있고, 직사각형의 수 n이 가장 처음으로 주어진다. (1 ≤ n ≤ 100,000) 그 다음 n개의 정수 h1, ..., hn (0 ≤ hi ≤ 1,000,000,000)가 주어진다. 이 숫자들은 히스토그램에 있는 직사각형의 높이이며, 왼쪽부터 오른쪽까지 순서대로 주어진다. 모든 직사각형의 너비는 1이고, 입력의 마지막 줄에는 0이 하나 주어진다.
### 출력
각 테스트 케이스에 대해서, 히스토그램에서 가장 넓이가 큰 직사각형의 넓이를 출력한다.
### 제한
- 
### 예제
- 입력
```
7 2 1 4 5 1 3 3
4 1000 1000 1000 1000
0
```
- 출력
```
8
4000
``` 

### 풀이
- My solution1
```python
def get_max_rectangle(n, arr):
    check_list = {arr[0]:1}
    ret = arr[0]
    for i in range(1,n):
        if arr[i] not in check_list:
            check_list[arr[i]] = 0

        tmp_check_list = check_list.copy()
        for c in check_list:
            if c > arr[i]:
                ret = max(ret,c*check_list[c])
                tmp_check_list.pop(c)
            else:
                tmp_check_list[c] +=1
        check_list = tmp_check_list
    if check_list:
        for c in check_list:
            ret = max(ret,c*check_list[c])
    return ret

while True:
    tmp_str = input()
    if tmp_str == '0':
        break
    else :
        arr = list(map(int,tmp_str.split()))
        n = arr.pop(0)
        print(get_max_rectangle(n, arr))
```
- My Answer 2
```python
def get_max_rectangle(n, arr):
    check_stack = [(0,arr[0])]
    ret = arr[0]
    for i in range(1,n):
        while True:
            if not check_stack or check_stack[-1][1] <= arr[i]:
                break
            else:
                tmp_stack = check_stack.pop()
                if check_stack:
                    start = check_stack[-1][0]+1
                else:
                    start = 0
                ret = max(ret,(i-start)*tmp_stack[1])                

        if not check_stack or check_stack[-1][1] <= arr[i]:
            check_stack.append((i,arr[i]))
    if check_stack:
        while True:
            if not check_stack:
                break
            else:
                tmp_stack = check_stack.pop()
                if check_stack:
                    start = check_stack[-1][0]+1
                else:
                    start = 0
                ret = max(ret,(n-start)*tmp_stack[1])
    return ret

while True:
    tmp_str = input()
    if tmp_str == '0':
        break
    else :
        arr = list(map(int,tmp_str.split()))
        n = arr.pop(0)
        print(get_max_rectangle(n, arr))
```
- Answer
```python
# 히스토그램에서 가장 큰 직사각형
import sys
input = sys.stdin.readline

def histogram(N, read):
    stack = []
    answer = 0
    read.append(0)

    for i in range(N+1):
        value = read[i]
        start = i
        while stack and stack[-1][1] >= value :
            start, height = stack.pop()
            answer = max(answer, (i-start)*height)
        stack.append([start, value])
    
    print(answer)

while True :
    read = list(map(int,input().split(' ')))
    N = read[0]
    if N == 0 :
        break
    histogram(N, read[1:])
```

- Analyze
	- My solution1
		- 평범하게 구해선 무조건 시간초과가 나온다. (O($n!$)의 시간 복잡도를 가진다.)
		- 때문에 조금이라도 적게 계산하기 위해 입력 받은 값의 check_list를 만들어주고 해당 값보다 크면 더 이상 해당 높이의 계산을 이어 갈 수 없기에 ret와 비교하고 pop해주고 작거나 같으면 높이 계산을 추가해 주었다.
		- 쉽게 말해 입력받은 수의 가장 작은 높이가 1이라면 해당 값은 계속 계산해 주어야한다.
		- 생각은 괜찮았던 것 같지만 timeout..
	- My solution2
		- 매우 많은 실패를 반복하고 반례를 찾아서 해결했다..
		- 우선 stack에 존재하지 않은 경우, 가장 작은 높이 이므로 start 지점을 0으로 주어야한다. (만약 있으면, 해당 값이 start 지점)
	- soultion
		- 짧고 간결하고 잘 구했다. 다시 한번 풀땐 저리 풀어봐야겠다.
### 알고리즘 분류
- 