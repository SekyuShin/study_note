 # 중앙값 구하기
Created at : 2026-01-08 22:10
[baekjoon_2696](https://www.acmicpc.net/problem/2696)
### 조건
- 시간 : 1
- 메모리 : 128
### 문제
어떤 수열을 읽고, 홀수번째 수를 읽을 때 마다, 지금까지 입력받은 값의 중앙값을 출력하는 프로그램을 작성하시오.

예를 들어, 수열이 1, 5, 4, 3, 2 이면, 홀수번째 수는 1번째 수, 3번째 수, 5번째 수이고, 1번째 수를 읽었을 때 중앙값은 1, 3번째 수를 읽었을 때는 4, 5번째 수를 읽었을 때는 3이다.
### 입력
첫째 줄에 테스트 케이스의 개수 T(1 ≤ T ≤ 1,000)가 주어진다. 각 테스트 케이스의 첫째 줄에는 수열의 크기 M(1 ≤ M ≤ 9999, M은 홀수)이 주어지고, 그 다음 줄부터 이 수열의 원소가 차례대로 주어진다. 원소는 한 줄에 10개씩 나누어져있고, 32비트 부호있는 정수이다.
### 출력
각 테스트 케이스에 대해 첫째 줄에 출력하는 중앙값의 개수를 출력하고, 둘째 줄에는 홀수 번째 수를 읽을 때 마다 구한 중앙값을 차례대로 공백으로 구분하여 출력한다. 이때, 한 줄에 10개씩 출력해야 한다.
### 제한
- 
### 예제
- 입력
```
3
9
1 2 3 4 5 6 7 8 9
9
9 8 7 6 5 4 3 2 1
23
23 41 13 22 -3 24 -31 -11 -8 -7
3 5 103 211 -311 -45 -67 -73 -81 -99
-33 24 56
```
- 출력
```
5
1 2 3 4 5
5
9 8 7 6 5
12
23 23 22 22 13 3 5 5 3 -3
-7 -3
``` 

### 풀이
- My solution
```python
import heapq

T = int(input())

for _ in range(T):
    left_heap = []
    right_heap = []
    mid_var = 0
    N = int(input())
    sum_len = 0
    ret = []
    while True:
        if sum_len == N:
            break
        arr = list(map(int,input().split()))
        sum_len += len(arr)
        for i, a in enumerate(arr):
            if i%2 == 0:
                if not left_heap and not right_heap:
                    mid_var = a
                else:
                    left_max = -heapq.heappop(left_heap)
                    right_min = heapq.heappop(right_heap)
                    if a > left_max and a < right_min:
                        mid_var = a 
                        heapq.heappush(right_heap,right_min)
                        heapq.heappush(left_heap,-left_max)    
                    elif a <= left_max:
                        heapq.heappush(left_heap,-a)
                        heapq.heappush(right_heap,right_min)
                        mid_var = left_max
                    else:
                        heapq.heappush(right_heap,a)
                        heapq.heappush(left_heap,-left_max)
                        mid_var = right_min
                ret.append(mid_var)
            else:
                if a < mid_var:
                    heapq.heappush(right_heap,mid_var)
                    heapq.heappush(left_heap,-a)
                else:
                    heapq.heappush(right_heap,a)
                    heapq.heappush(left_heap,-mid_var)
    print(len(ret))
    for i, r in enumerate(ret):
        if i != 0 and i % 10 == 0:
            print()
        print(f"{r}",end=" ")
```

- Answer
```python

```

- Analyze
	- 입력되는 수를 작은 값들의 heap인 left_heap의 최대값과 큰 값들의 heap인 right_heap의 최솟값을 비교하고 mid_var를 정해준다.
	- 이후, 짝수 일 경우, 입력값과 mid_var를 비교하여 각각 left_heap과 right_heap에 넣어 주었다.
	- 처음 틀린 부분은 입력값이 left_max와 같을 때 발생했다.
		- (틀린 코드) elif a <= left_max:
			- 예시, left_max = 3, a = 3, right_min = 5 일 때, right_heap에 a인 3이 들어가고 mid_var의 값이 5가 되버린다.
### 알고리즘 분류
- 