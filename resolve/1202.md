 # 보석 도둑
Created at : 2026-01-09 23:06
[baekjoon_1202](https://www.acmicpc.net/problem/1202)
### 조건
- 시간 : 1
- 메모리 : 256
### 문제
세계적인 도둑 상덕이는 보석점을 털기로 결심했다.

상덕이가 털 보석점에는 보석이 총 N개 있다. 각 보석은 무게 $M_i$와 가격 $V_i$를 가지고 있다. 상덕이는 가방을 K개 가지고 있고, 각 가방에 담을 수 있는 최대 무게는 $C_i$이다. 가방에는 최대 한 개의 보석만 넣을 수 있다.

상덕이가 훔칠 수 있는 보석의 최대 가격을 구하는 프로그램을 작성하시오.
### 입력
첫째 줄에 N과 K가 주어진다. (1 ≤ N, K ≤ 300,000)

다음 N개 줄에는 각 보석의 정보 $M_i$와 $V_i$가 주어진다. (0 ≤ $M_i$ , $V_i$ ≤ 1,000,000)

다음 K개 줄에는 가방에 담을 수 있는 최대 무게 $C_i$가 주어진다. (1 ≤ $C_i$ ≤ 100,000,000)

모든 숫자는 양의 정수이다.
### 출력
첫째 줄에 상덕이가 훔칠 수 있는 보석 가격의 합의 최댓값을 출력한다.
### 제한
- 
### 예제
- 입력
```
2 1
5 10
100 100
11
```
- 출력
```
10
``` 
- 입력
```
3 2
1 65
5 23
2 99
10
2
```
- 출력
```
164
``` 
### 풀이
- My solution 1
```python
import sys
import heapq

N,K = map(int,sys.stdin.readline().strip().split())

jewel_heap = []
for _ in range(N):
    m,v = map(int,sys.stdin.readline().strip().split())
    heapq.heappush(jewel_heap, (-v,m))

bag_heap = []
for _ in range(K):
    c = int(sys.stdin.readline().strip())
    heapq.heappush(bag_heap,c)

value_sum = 0
for _ in range(len(bag_heap)):
    c = heapq.heappop(bag_heap)
    remain_jewel_list = []
    for _ in range(len(jewel_heap)):
        j = heapq.heappop(jewel_heap)
        if j[1] <= c:
            value_sum -= j[0]
            break
        else:
            remain_jewel_list.append(j)
    for r in remain_jewel_list:
        heapq.heappush(jewel_heap,r)
        
print(value_sum)
```

- My solution 2
```python

import sys
import heapq

N,K = map(int,sys.stdin.readline().strip().split())

jewel = {}
for _ in range(N):
    m,v = map(int,sys.stdin.readline().strip().split())
    if not jewel.get(m):
        jewel[m] = []
    heapq.heappush(jewel[m],-v)

bag_heap = []
for _ in range(K):
    c = int(sys.stdin.readline().strip())
    heapq.heappush(bag_heap,c)

value_sum = 0
last_c = 0
second_max_value = (-1, -1)
for _ in range(len(bag_heap)):
    c = heapq.heappop(bag_heap)
    max_value = second_max_value
    second_max_value = (-1, -1)
    for i in range(last_c, c+1):
        if jewel.get(i):
            j = heapq.heappop(jewel[i])
            if -j > max_value[1]:
                if second_max_value[0] != -1:
                    heapq.heappush(jewel[second_max_value[0]],-second_max_value[1])
                second_max_value = max_value
                max_value = (i,-j)
            elif -j > second_max_value[1]:
                if second_max_value[0] != -1:
                    heapq.heappush(jewel[second_max_value[0]],-second_max_value[1])
                second_max_value = (i,-j)
            else:
                heapq.heappush(jewel[i],j)
    if max_value != (-1,-1):
        value_sum += max_value[1]
    last_c = c
        
print(value_sum)
```
- My solution 3
```python
import sys
import heapq

N,K = map(int,sys.stdin.readline().strip().split())

jewel_heap = []
for _ in range(N):
    m,v = map(int,sys.stdin.readline().strip().split())
    heapq.heappush(jewel_heap, (m,v))

bag_heap = []
for _ in range(K):
    c = int(sys.stdin.readline().strip())
    heapq.heappush(bag_heap,c)

value_sum = 0
jewel_value_heap = []
for _ in range(len(bag_heap)):
    c = heapq.heappop(bag_heap)
    while len(jewel_heap) > 0:
        j = heapq.heappop(jewel_heap)
        if j[0] <= c:
            heapq.heappush(jewel_value_heap,-j[1])
        else:
            heapq.heappush(jewel_heap,j)
            break
    if jewel_value_heap:
        value_sum -= heapq.heappop(jewel_value_heap)
        
print(value_sum)
```
- Answer
```python

```

- Analyze
	- My solution 1 (시간 초과)
		- jewel_heap에 value가 큰 순으로 넣어주고, 무게가 주머니에 담기지 않으면 remain_jewel_list에 추가해서 계산이 끝난 후, 다시 jewel_heap에 넣어주는 방식이다.
		- 안정적이긴 하나 시간초과..
	- My solution 2 (틀림)
		- 생각 자체는 괜찮았던거 같은데 틀렸다.
		- 무게를 기준으로 dictionary 형태로 저장하되 value값으론 heapq의 형태로 가치를 넣어주었다. (가치가 높은 순서)
		- 이후 작업에선 무게까지의 최대값과 그 다음 최대값을 저장한 뒤에 누적 합을 구해주었다.
		- 쓰다가 생각난건데,  jewel의 heapq에 두 번째로 높은 가치가 있으면 skip된다.
	- My Solution 3
		- 위의 코드는 너무 지저분해 지기에 비슷하게 구현해 보았다.
		- 먼저 jewel_heap에 무게가 작은 순으로 heap을 넣어주고
		- 마찬가지로 bag_heap에 무게가 작은 순으로 heap을 넣어주었다.
		- 이후, bag_heap을 pop하며 나온 무게에 맞추어 jewel_heap을 pop해 주고, 이 값들을 다시금 jewel_value_heap에 push 해주었다. (최대 heap)
		- 해당 작업이 끝난 뒤에 jewel_value_heap에서 pop해 주면 최대 가치의 jewel을 알 수 있다.
### 알고리즘 분류
- 