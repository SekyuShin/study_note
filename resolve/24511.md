# queuestack
Created at : 2025-10-12 18:28
[baekjoon_24511](https://www.acmicpc.net/problem/24511)
### 조건
- 시간 : 1
- 메모리 : 1024
### 문제
한가롭게 방학에 놀고 있던 도현이는 갑자기 재밌는 자료구조를 생각해냈다. 그 자료구조의 이름은 queuestack이다.

queuestack의 구조는 다음과 같다. $1$번, $2$번, ... , $N$번의 자료구조(queue 혹은 stack)가 나열되어있으며, 각각의 자료구조에는 한 개의 원소가 들어있다.

queuestack의 작동은 다음과 같다.

-  $x_0$을 입력받는다.
-  $x_0$을 $1$번 자료구조에 삽입한 뒤 $1$번 자료구조에서 원소를 pop한다. 그때 pop된 원소를 $x_1$이라 한다.
-  $x_1$을 $2$번 자료구조에 삽입한 뒤 $2$번 자료구조에서 원소를 pop한다. 그때 pop된 원소를 $x_2$이라 한다.
- ...
-  $x_{N-1}$을 $N$번 자료구조에 삽입한 뒤 $N$번 자료구조에서 원소를 pop한다. 그때 pop된 원소를 $x_N$이라 한다.
-  $x_N$을 리턴한다.

도현이는 길이 $M$의 수열 $C$를 가져와서 수열의 원소를 앞에서부터 차례대로 queuestack에 삽입할 것이다. 이전에 삽입한 결과는 남아 있다. (예제 $1$ 참고)

queuestack에 넣을 원소들이 주어졌을 때, 해당 원소를 넣은 리턴값을 출력하는 프로그램을 작성해보자.
### 입력
첫째 줄에 queuestack을 구성하는 자료구조의 개수 $N$이 주어진다. ($1 \leq N \leq 100\,000$)

둘째 줄에 길이 $N$의 수열 $A$가 주어진다. $i$번 자료구조가 큐라면 $A_i = 0$, 스택이라면 $A_i = 1$이다.

셋째 줄에 길이 $N$의 수열 $B$가 주어진다. $B_i$는 $i$번 자료구조에 들어 있는 원소이다. ($1 \leq B_i \leq 1\,000\,000\,000$)

넷째 줄에 삽입할 수열의 길이 $M$이 주어진다. ($1 \leq M \leq 100\,000$)

다섯째 줄에 queuestack에 삽입할 원소를 담고 있는 길이 $M$의 수열 $C$가 주어진다. ($1 \leq C_i \leq 1\,000\,000\,000$)

입력으로 주어지는 모든 수는 정수이다.
### 출력
수열 $C$의 원소를 차례대로 queuestack에 삽입했을 때의 리턴값을 공백으로 구분하여 출력한다.
### 제한
- 
### 예제
- 입력
```
4
0 1 1 0
1 2 3 4
3
2 4 7
```
- 출력
```
4 1 2
``` 
각 상태에 대한 큐스택 내부를 표현하면 다음과 같다.

- 초기 상태 : $[1, 2, 3, 4]$ 
- 첫 번째 원소 삽입 : $[2, 2, 3, 1]$ 
- 두 번째 원소 삽입 : $[4, 2, 3, 2]$ 
- 세 번째 원소 삽입 : $[7, 2, 3, 4]$
- 입력
```
5
1 1 1 1 1
1 2 3 4 5
3
1 3 5
```
- 출력
```
1 3 5
``` 

### 풀이
- My solution 1 (시간 초과)
```python
import sys

N = int(sys.stdin.readline().strip())
A = list(map(int,sys.stdin.readline().strip().split()))
B = list(map(int,sys.stdin.readline().strip().split()))
M = int(sys.stdin.readline().strip())
C = list(map(int,sys.stdin.readline().strip().split()))

# 숫자 list이기에 c를 수정해도 List c가 바뀌지 않기에 ret를 따로 두었다.
# ret = []
# for c in C:
#     for i in range(N):
#         tmp_ret = None
#         if A[i] == 0:
#             tmp_ret = B[i]
#             B[i] = c
#             c = tmp_ret
#         elif A[i] == 1:
#             continue
#     ret.append(c)  

# print(" ".join(map(str,ret)))

for c in range(len(C)):
    for i in range(N):
        tmp_ret = None
        if A[i] == 0:
            tmp_ret = B[i]
            B[i] = C[c]
            C[c] = tmp_ret
        elif A[i] == 1:
            continue 

print(" ".join(map(str,C)))
```
- My solution 2 (148ms)
```python
import sys
from collections import deque

N = int(sys.stdin.readline().strip())
A = list(map(int,sys.stdin.readline().strip().split()))
B = list(map(int,sys.stdin.readline().strip().split()))
M = int(sys.stdin.readline().strip())
C = list(map(int,sys.stdin.readline().strip().split()))
ret = []

queue = deque()

for n in range(N):
    if A[n] == 0:
        queue.append(B[n])

for c in C:
    queue.appendleft(c)
    ret.append(queue.pop())

print(" ".join(map(str,ret)))
```

- Answer
```python

```

- Analyze
	- 이해하기 힘들 땐, 예제를 면밀히 보자.
	- My solution1
		- 처음 시도한 My solution1은 곧이곧대로 진행해 보았다. (시간 초과) 
		- stack은 자연히 그대로 남겨지며, queue만 실제 queue처럼 동작하기에 C List에 두어서 이전 pop된 값을 저장하고 이후 queue에서 push하는데 사용되었다. 
		- 일일이 값을 저장하고 빼기에 시간이 오래 걸린듯 싶다.
		- List의 불변성 `for c in C` (참조)
			1. 숫자(정수, 실수 등)와 문자열(str), 튜플(tuple)은 불변(Immutable) 객체입니다.
				- 이들은 한 번 생성되면 그 값을 변경할 수 없습니다. `c = B[i]`처럼 값을 변경하는 것은 실제로는 `c`가 새로운 숫자 객체를 가리키도록 하는 재할당(reassignment)입니다. 
				- 원본 리스트 `C`에 있는 객체 자체는 변하지 않습니다.
			2. 리스트(list), 딕셔너리(dictionary), 사용자 정의 클래스의 인스턴스(객체)는 가변(Mutable) 객체입니다. 
				- 이들은 객체 자체의 내용(요소, 속성)을 변경할 수 있습니다. `for c in C:`에서 `c`는 리스트 `C`에 있는 해당 객체에 대한 참조(reference)를 가져옵니다. 
				- 즉, `c`와 `C[i]`는 같은 메모리 주소에 있는 동일한 객체를 가리키고 있습니다.
	- My solution 2
		- 보다 보니 규칙성이 발견되었다. queue로 지정된 자료 구조들만 따로 빼둔다면 이는 역 queue의 동작을 가진다. (선입선출) ->앞에서 push하고 뒤에서 pop되는 것만 다르다. 
### 알고리즘 분류
- 자료 구조
- 스택
- 덱
- 큐