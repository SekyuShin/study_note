 # 곱셈
Created at : 2025-12-17 21:27
[baekjoon_1629](https://www.acmicpc.net/problem/1629)
### 조건
- 시간 : 0.5
- 메모리 : 128
### 문제
자연수 A를 B번 곱한 수를 알고 싶다. 단 구하려는 수가 매우 커질 수 있으므로 이를 C로 나눈 나머지를 구하는 프로그램을 작성하시오.
### 입력
첫째 줄에 A, B, C가 빈 칸을 사이에 두고 순서대로 주어진다. A, B, C는 모두 2,147,483,647 이하의 자연수이다.
### 출력
첫째 줄에 A를 B번 곱한 수를 C로 나눈 나머지를 출력한다.
### 제한
- 
### 예제
- 입력
```
10 11 12
```
- 출력
```
4
``` 

### 풀이
- My solution1
```python
import sys
sys.setrecursionlimit(2147483647)

A,B,C = map(int,input().split())
ret_list = []
def check_num(ret, n):
    if n == B:
        return ret        
    else:
        ret = ret*A%C        
        if not ret in ret_list:
            ret_list.append(ret)
        else:
            find_idx = ret_list.index(ret)
            sel_idx = (B-n-1)%(len(ret_list)-find_idx)
            return ret_list[find_idx+sel_idx]
        return check_num(ret,n+1)

print(check_num(1,0))
```
- My Solution 2
```python
A,B,C = map(int,input().split())
ret_list = [A]
ret = -1
for i in range(1, B):
    ret = ret_list[-1]*A % C
    if ret in ret_list:
        find_idx = ret_list.index(ret)
        sel_idx = (B-i-1)%(len(ret_list)-find_idx)
        ret = ret_list[find_idx+sel_idx]
        break
    else :
        ret_list.append(ret)
print(ret)
```
- Answer
```python

```

- Analyze
	- My Solution1 
		- 각 자연수가 21억을 가지는 매우 큰 수이다.
		- 때문에 직접 구하는 건 불가능으로 보고 규칙성을 찾았다.
			```
			2 11 12
			1 - 2
			2 - 4
			3 - 8
			4 - 16(4)
			5 - 32(8)
			...
			10 - 1024 (4)
			11 - 2048 (8)
			즉, [2, 4, 8]의 결과 중, [4, 8]의 반복을 답으로 가진다.
			
			11 10 12
			1 - 11
			2 - 121 (1)
			...
			10 - 25937424601(1)
			즉, [11, 1]의 결과 중, [11, 1] 반복을 답으로 가진다.
			```
		- 위의 결과를 통해 반복되는 부분을 찾고 구해보았지만, 시간 초과... 아무래도 값이 크닌깐 재귀로 반복되는 부분을 찾기 전까지 시간 초과가 나오는 하다.
	- My Solution 2
		- 위와 비슷한 형태이긴 하나 반복문으로만 해 보았지만 역시.. 
### 알고리즘 분류
- 