 # 곱셈
Created at : 2025-12-17 21:27
[baekjoon_1629](https://www.acmicpc.net/problem/1629)
### 조건
- 시간 : 0.5
- 메모리 : 128
### 문제
자연수 A를 B번 곱한 수를 알고 싶다. 단 구하려는 수가 매우 커질 수 있으므로 이를 C로 나눈 나머지를 구하는 프로그램을 작성하시오.
### 입력
첫째 줄에 A, B, C가 빈 칸을 사이에 두고 순서대로 주어진다. A, B, C는 모두 2,147,483,647 이하의 자연수이다.
### 출력
첫째 줄에 A를 B번 곱한 수를 C로 나눈 나머지를 출력한다.
### 제한
- 
### 예제
- 입력
```
10 11 12
```
- 출력
```
4
``` 

### 풀이
- My solution1
```python
import sys
sys.setrecursionlimit(2147483647)

A,B,C = map(int,input().split())
ret_list = []
def check_num(ret, n):
    if n == B:
        return ret        
    else:
        ret = ret*A%C        
        if not ret in ret_list:
            ret_list.append(ret)
        else:
            find_idx = ret_list.index(ret)
            sel_idx = (B-n-1)%(len(ret_list)-find_idx)
            return ret_list[find_idx+sel_idx]
        return check_num(ret,n+1)

print(check_num(1,0))
```
- My Solution 2
```python
A,B,C = map(int,input().split())
ret_list = [A]
ret = -1
for i in range(1, B):
    ret = ret_list[-1]*A % C
    if ret in ret_list:
        find_idx = ret_list.index(ret)
        sel_idx = (B-i-1)%(len(ret_list)-find_idx)
        ret = ret_list[find_idx+sel_idx]
        break
    else :
        ret_list.append(ret)
print(ret)
```
- Answer
```python
def b_div(a,b,c):
    if b == 1:
        return a%c
    elif b == 0:
        return 1
    tmp_ret = b_div(a,b//2,c)
    if b%2 == 1: #odd
        return tmp_ret*tmp_ret*a%c
    else:
        return tmp_ret*tmp_ret%c

A,B,C = map(int,input().split())
print(b_div(A,B,C))
```

- Analyze
	- My Solution1 
		- 각 자연수가 21억을 가지는 매우 큰 수이다.
		- 때문에 직접 구하는 건 불가능으로 보고 규칙성을 찾았다.
			```
			2 11 12
			1 - 2
			2 - 4
			3 - 8
			4 - 16(4)
			5 - 32(8)
			...
			10 - 1024 (4)
			11 - 2048 (8)
			즉, [2, 4, 8]의 결과 중, [4, 8]의 반복을 답으로 가진다.
			
			11 10 12
			1 - 11
			2 - 121 (1)
			...
			10 - 25937424601(1)
			즉, [11, 1]의 결과 중, [11, 1] 반복을 답으로 가진다.
			```
	- My Solution 2
		- 반례 : 2 2000000000 999999937 (999999937은 소수)
		- ret_list가 미친듯이 커지는 (순환되지 않는 부분이 존재)하는 것으로 보인다.
	- Answer
		- ![[Pasted image 20251218232801.png]]
		- 위 처럼 제곱수를 쪼개서 분할 정복을 통한 제곱수를 구하는 방식이다.
		- 분배 법칙까지 사용하여 %C를 해주면된다.
		- 시간복잡도가 O(B)에서 O(logB)로 확 줄어든다.
			- O(100) => O(log100) => O(2)
			- 쉬운 예시로 2^100보다, ((((2^3)^2)^2`*`2)^2)^2 를 계산하는게 훨씬 빠르다.
### 알고리즘 분류
- 