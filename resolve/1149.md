 # RGB거리
Created at : 2025-11-14 23:31
[baekjoon_1149](https://www.acmicpc.net/problem/1149)
### 조건
- 시간 : 0.5
- 메모리 : 128
### 문제
RGB거리에는 집이 N개 있다. 거리는 선분으로 나타낼 수 있고, 1번 집부터 N번 집이 순서대로 있다.

집은 빨강, 초록, 파랑 중 하나의 색으로 칠해야 한다. 각각의 집을 빨강, 초록, 파랑으로 칠하는 비용이 주어졌을 때, 아래 규칙을 만족하면서 모든 집을 칠하는 비용의 최솟값을 구해보자.

- 1번 집의 색은 2번 집의 색과 같지 않아야 한다.
- N번 집의 색은 N-1번 집의 색과 같지 않아야 한다.
- i(2 ≤ i ≤ N-1)번 집의 색은 i-1번, i+1번 집의 색과 같지 않아야 한다.
### 입력
첫째 줄에 집의 수 N(2 ≤ N ≤ 1,000)이 주어진다. 둘째 줄부터 N개의 줄에는 각 집을 빨강, 초록, 파랑으로 칠하는 비용이 1번 집부터 한 줄에 하나씩 주어진다. 집을 칠하는 비용은 1,000보다 작거나 같은 자연수이다.
### 출력
첫째 줄에 모든 집을 칠하는 비용의 최솟값을 출력한다.
### 제한
- 
### 예제
- 입력
```
3
26 40 83
49 60 57
13 89 99
```
- 출력
```
96
``` 
- 입력
```
3
1 100 100
100 1 100
100 100 1
```
- 출력
```
3
``` 
- 입력
```
3
1 100 100
100 100 100
1 100 100
```
- 출력
```
102
``` 
- 입력
```
6
30 19 5
64 77 64
15 19 97
4 71 57
90 86 84
93 32 91
```
- 출력
```
208
``` 
- 입력
```
8
71 39 44
32 83 55
51 37 63
89 29 100
83 58 11
65 13 15
47 25 29
60 66 19
```
- 출력
```
253
``` 

### 풀이
- My solution (시간 초과)
```python
n = int(input())
arr = []
for _ in range(n):
    tmp_arr = list(map(int,input().split()))
    arr.append(tmp_arr)
    ret = []
def dfs(sel, sum, cnt):
    if cnt == n:
        ret.append(sum)
        return
    else:
        for i in range(3):
            if i == sel:
                continue
            sum += arr[cnt][i]
            dfs(i,sum,cnt+1)
            sum -= arr[cnt][i]

dfs(0,0,0)
dfs(1,0,0)
dfs(2,0,0)
print(min(ret))
```

- My solution2 (56 ms)
```python
n = int(input())
arr = []
for _ in range(n):
    tmp_arr = list(map(int,input().split()))
    arr.append(tmp_arr)

ret = arr[0].copy()
for i in range(1,n):
    tmp_ret = ret.copy()
    ret[0] = arr[i][0] + min(tmp_ret[1],tmp_ret[2])
    ret[1] = arr[i][1] + min(tmp_ret[0],tmp_ret[2])
    ret[2] = arr[i][2] + min(tmp_ret[0],tmp_ret[1])
print(min(ret))
```
- Answer
```python

```

- Analyze
	- My Solution1은 완전 탐색으로 당연히 시간 초과가 나왔다.
	- My Solution2
		- 사실 계속 고민하다 살짝 컨닝했다.
		- 발상의 전환이 필요했는데, 이전까지의 결과에 대해서 현재 결과를 더했을 때의 최솟값을 구하는 것이다. 
		- 즉, 현재 어떤 컬러를 선택할지 정하고 더 하는게 아닌 전의 결과들에 대해서 최솟값을 구하는 방식이다.
		- ![[Pasted image 20251115231621.png]]
### 알고리즘 분류
- 