 # 가장 긴 증가하는 부분 수열 2
Created at : 2026-01-03 21:02
[baekjoon_12015](https://www.acmicpc.net/problem/12015)
### 조건
- 시간 : 1
- 메모리 : 512
### 문제
수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.

예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {**10**, **20**, 10, **30**, 20, **50**} 이고, 길이는 4이다.
### 입력
첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다.

둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ Ai ≤ 1,000,000)
### 출력
첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다.
### 제한
- 
### 예제
- 입력
```
6
10 20 10 30 20 50
```
- 출력
```
4
``` 

### 풀이
- My solution
```python
N = int(input())
arr = list(map(int,input().split()))
LIS = [arr[0]]

def binary_searching(target,start,end):
    if start > end:
        LIS[start] = target
        return
    mid = (start+end)//2
    if LIS[mid] < target:
        binary_searching(target, mid+1, end)
    else:
        binary_searching(target, start, mid-1)

for a in arr:
    if LIS[-1] < a:
        LIS.append(a)
    else:
        binary_searching(a,0,len(LIS)-1)

print(len(LIS))
```

- Answer
```python

```

- Analyze
	- 힌트를 또 봤다.. 이런 방법이 있을 줄이야.
	- 결론부터 얘기하자면, LIS에 마지막 값과 비교하여 크면 추가해주고 작으면 binary searching을 통해 치환할 값을 찾아준다 (이전 값보단 크고 이후 값보단 작은). 이는 정확한 LIS는 아닐 수 있지만, 길이 자체는 동일하게 구할 수 있다.
	- $A = [10, 20, 30, 15, 50]$을 예시로 들면
		- 우선 LIS의 값은 $[10,20,30,50]$ 이다.
		- 다만 위의 알고리즘을 하게 되면 길이는 4로 동일하지만, LIS는 $[10,15,30,50]$을 출력한다.
		- Input 10 => LIS = $[10]$
		- Input 20 => LIS = $[10,20]$
		- Input 30 => LIS = $[10,20,30]$
		- Input 15 => LIS = $[10,20,30]$ , $[10,15]$ 
			- 위의 알고리즘을 적용하면 LIS = $[10,15,30]$
		- Input 50 => LIS = $[10,20,30,50]$ , $[10,15,50]$ 
			- 위의 알고리즘을 적용하면 LIS = $[10,15,30,50]$
		- 이렇듯 해당 알고리즘의 길이는 동일한 이유는 **다음에 올지도 모르는 긴 수열**을 대비 한 것이라 보면된다.
			- 만약 A의 뒤에 $[20,30,40]$이 있었다면 정확한 LIS 값을 가지게 된다
			- A = $[10,20,30,15,50,20,30,40]$
			- LIS => $[10,20,30,50]$, $[10,15,20,30,40]$
			- 이렇든 도중에 바뀌는 건 이후 더 긴 수열이 올 경우에 가장 매칭되는 idx에 작은 값을 넣어주면 Switching 되며 실제 LIS 값과 동일하게 된다.
			- 때문에 실제 LIS 값과는 맞지 않더라도 길이는 정확하게 맞게된다.
### 알고리즘 분류
- 