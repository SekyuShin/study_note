 # K번째 수
Created at : 2026-01-02 20:45
[baekjoon_1300](https://www.acmicpc.net/problem/1300)
### 조건
- 시간 : 2
- 메모리 : 128
### 문제
세준이는 크기가 N×N인 배열 A를 만들었다. 배열에 들어있는 수 A[i][j] = i×j 이다. 이 수를 일차원 배열 B에 넣으면 B의 크기는 N×N이 된다. B를 오름차순 정렬했을 때, B[k]를 구해보자.

배열 A와 B의 인덱스는 1부터 시작한다.
### 입력
첫째 줄에 배열의 크기 N이 주어진다. N은 105보다 작거나 같은 자연수이다. 둘째 줄에 k가 주어진다. k는 $min(10^9, N^2)$보다 작거나 같은 자연수이다.
### 출력
B[k]를 출력한다.
### 제한
- 
### 예제
- 입력
```
3
7
```
- 출력
```
6
``` 

### 풀이
- My solution
```python
N = int(input())
k = int(input())

ret = []
def binary_searching(start, end):
    if start > end:
        return
    mid = (start+end)//2
    tmp_cnt = 0
    for i in range(1,N+1):
        tmp_cnt += min(mid//i, N)
    if tmp_cnt >= k:
        ret.append(mid)
        binary_searching(start,mid-1)
    else:
        binary_searching(mid+1,end)


binary_searching(1,k)
print(min(ret))
```

- Answer
```python

```

- Analyze
	- 그냥 반복문으로 풀면 시간 초과 및 메모리 초과가 나올 만큼의 N이 주어졌다.
	- 가장 큰 문제는 sort를 하지 않고 순서인 k의 값을 구해야 하는 것이다.
	- 여러 방면으로 생각해보다, 임의의 숫자 A보다 작거나 같은 숫자의 개수를 세면 된다. 다만, 작거나 같은 숫자의 개수를 세는 방법에서 고민을 많이 했지만 결국 힌트를 봤다.
	- 우선 결론은 S보다 작거나 같은 값들의 개수를 구하는 공식은 $min(mid//i, N)$이다.
		- 힌트 글을 참조해서 정리
			- S가 8이라고 가정해보자.
			- ![[Pasted image 20260102231623.png]]
			- 조금만 더 생각을 해보면, $A[i,j] = i*j$이다. 여기서 i를 특정할 수 있다면, 목표하는 임의의 값 S보다 작은 수를 쉽게 구할수 있다.
				- S = 8, i = 1이라면, $i*j$는 $1*1$, $1*2$, $1*3$, $1*4$, $1*5$
				- S = 8, i = 2 이라면, $i*j$는 $2*1$, $2*2$, $2*3$, $2*4$, $2*5$
				- ...
				- 여기서, i를 2라고 특정하고 양 변에 i로 나누어서 계산하면 j는 자연스럽게 반복문의 형태로 나온다.
					- S = 8/2 = 4, j_list =$[2*1/2, 2*2/2, 2*3/2, 2*4/2, 2*5/2]$ = $[1,2,3,4,5]$
					- 즉, S가 4보다 작거나 같은 수는 1,2,3,4로 볼 수 있다.
### 알고리즘 분류
- 