 # K번째 수
Created at : 2026-01-02 20:45
[baekjoon_1300](https://www.acmicpc.net/problem/1300)
### 조건
- 시간 : 2
- 메모리 : 128
### 문제
세준이는 크기가 N×N인 배열 A를 만들었다. 배열에 들어있는 수 A[i][j] = i×j 이다. 이 수를 일차원 배열 B에 넣으면 B의 크기는 N×N이 된다. B를 오름차순 정렬했을 때, B[k]를 구해보자.

배열 A와 B의 인덱스는 1부터 시작한다.
### 입력
첫째 줄에 배열의 크기 N이 주어진다. N은 105보다 작거나 같은 자연수이다. 둘째 줄에 k가 주어진다. k는 $min(10^9, N^2)$보다 작거나 같은 자연수이다.
### 출력
B[k]를 출력한다.
### 제한
- 
### 예제
- 입력
```
3
7
```
- 출력
```
6
``` 

### 풀이
- My solution
```python
N = int(input())
k = int(input())

ret = []
def binary_searching(start, end):
    if start > end:
        return
    mid = (start+end)//2
    tmp_cnt = 0
    for i in range(1,N+1):
        tmp_cnt += min(mid//i, N)
    if tmp_cnt >= k:
        ret.append(mid)
        binary_searching(start,mid-1)
    else:
        binary_searching(mid+1,end)


binary_searching(1,k)
print(min(ret))
```

- Answer
```python

```

- Analyze
	- 그냥 반복문으로 풀면 시간 초과 및 메모리 초과가 나올 만큼의 N이 주어졌다.
	- 가장 큰 문제는 sort를 하지 않고 순서인 k의 값을 구해야 하는 것이다.
	- 여러 방면으로 생각해보다, 임의의 숫자 A보다 작거나 같은 숫자의 개수를 세면 된다. 다만, 작거나 같은 숫자의 개수를 세는 방법에서 고민을 많이 했지만 결국 힌트를 봤다.
	- 우선 결론은 S보다 작거나 같은 값들의 개수를 구하는 공식은 $min(mid//i, N)$이다.
		- 힌트 글을 참조해서 정리
			- S가 8이라고 가정해보자.
			- ![[Pasted image 20260102231623.png]]
			- i 인 경우를 보면, $i*1$, $i*2$, $i*3$, $i*4$, $i*5$이다. 
			- 정리 필요
			- 조건문을 보면 if $S >= i*1$ 를 만족해야 숫자의 개수가 count 되는데 여기서 확정 할 수 있는 수는 i이기에 S를 i로 나눈 몫의 값을 구하면 조건이 성립하는지 알 수 있게 된다. if S//i >= $i*1//i$ 
			- 좀 더 정리하면, S//i
### 알고리즘 분류
- 