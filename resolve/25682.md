 # 체스판 다시 칠하기 2
Created at : 2025-12-06 01:05
[baekjoon_25682](https://www.acmicpc.net/problem/25682)
### 조건
- 시간 : 1
- 메모리 : 256
### 문제
지민이는 자신의 저택에서 MN개의 단위 정사각형으로 나누어져 있는 M×N 크기의 보드를 찾았다. 어떤 정사각형은 검은색으로 칠해져 있고, 나머지는 흰색으로 칠해져 있다. 지민이는 이 보드를 잘라서 K×K 크기의 체스판으로 만들려고 한다.

체스판은 검은색과 흰색이 번갈아서 칠해져 있어야 한다. 구체적으로, 각 칸이 검은색과 흰색 중 하나로 색칠되어 있고, 변을 공유하는 두 개의 사각형은 다른 색으로 칠해져 있어야 한다. 따라서 이 정의를 따르면 체스판을 색칠하는 경우는 두 가지뿐이다. 하나는 맨 왼쪽 위 칸이 흰색인 경우, 하나는 검은색인 경우이다.

보드가 체스판처럼 칠해져 있다는 보장이 없어서, 지민이는 K×K 크기의 체스판으로 잘라낸 후에 몇 개의 정사각형을 다시 칠해야겠다고 생각했다. 당연히 K×K 크기는 아무데서나 골라도 된다. 지민이가 다시 칠해야 하는 정사각형의 최소 개수를 구하는 프로그램을 작성하시오.
### 입력
첫째 줄에 정수 N, M, K가 주어진다. 둘째 줄부터 N개의 줄에는 보드의 각 행의 상태가 주어진다. B는 검은색이며, W는 흰색이다.
### 출력
첫째 줄에 지민이가 잘라낸 K×K 보드를 체스판으로 만들기 위해 다시 칠해야 하는 정사각형 개수의 최솟값을 출력한다.
### 제한
- 1 ≤ N, M ≤ 2000
- 1 ≤ K ≤ min(N, M)
### 예제
- 입력
```
4 4 3
BBBB
BBBB
BBBW
BBWB
```
- 출력
```
2
``` 
- 입력
```
8 8 8
WBWBWBWB
BWBWBWBW
WBWBWBWB
BWBBBWBW
WBWBWBWB
BWBWBWBW
WBWBWBWB
BWBWBWBW
```
- 출력
```
1
``` 
- 입력
```
10 13 10
BBBBBBBBWBWBW
BBBBBBBBBWBWB
BBBBBBBBWBWBW
BBBBBBBBBWBWB
BBBBBBBBWBWBW
BBBBBBBBBWBWB
BBBBBBBBWBWBW
BBBBBBBBBWBWB
WWWWWWWWWWBWB
WWWWWWWWWWBWB
```
- 출력
```
30
``` 
- 입력
```
9 23 9
BBBBBBBBBBBBBBBBBBBBBBB
BBBBBBBBBBBBBBBBBBBBBBB
BBBBBBBBBBBBBBBBBBBBBBB
BBBBBBBBBBBBBBBBBBBBBBB
BBBBBBBBBBBBBBBBBBBBBBB
BBBBBBBBBBBBBBBBBBBBBBB
BBBBBBBBBBBBBBBBBBBBBBB
BBBBBBBBBBBBBBBBBBBBBBB
BBBBBBBBBBBBBBBWWWWWWWW
```
- 출력
```
40
``` 

### 풀이
- My solution
```python

import sys

def check_board(board, x1,y1,x2,y2):
    result = 0
    if x1 == 0 and y1 == 0:
        result = board[x2][y2]
    elif x1 == 0:
        result = board[x2][y2] - board[x2][y1-1]
    elif y1 == 0:
        result = board[x2][y2] - board[x1-1][y2]
    else:
        result = board[x2][y2]-board[x1-1][y2]-board[x2][y1-1]+board[x1-1][y1-1]
    return result

N,M,K = map(int,sys.stdin.readline().strip().split())

arr = []
w_board = [[0]*N for _ in range(N)]
b_board = [[0]*N for _ in range(N)]
for i in range(N):
    tmp_arr = sys.stdin.readline().strip()
    arr.append(tmp_arr)
    for j in range(N):
        if (i+j)%2 == 0:
            if tmp_arr[j] == "B":
                w_board[i][j] = 1
            else :
                b_board[i][j] = 1
        else:
            if tmp_arr[j] == "W":
                w_board[i][j] = 1
            else:
                b_board[i][j] = 1

w_board_ret = [[0]*N for _ in range(N)]
b_board_ret = [[0]*N for _ in range(N)]
for i in range(N):
    for j in range(N):
        if i == 0 and j == 0:
            w_board_ret[i][j] = w_board[0][0]
            b_board_ret[i][j] = b_board[0][0]
        elif i == 0:
            w_board_ret[i][j] = w_board_ret[i][j-1]+w_board[i][j]
            b_board_ret[i][j] = b_board_ret[i][j-1]+b_board[i][j]
        elif j == 0:
            w_board_ret[i][j] = w_board_ret[i-1][j]+w_board[i][j]
            b_board_ret[i][j] = b_board_ret[i-1][j]+b_board[i][j]
        else:
            w_board_ret[i][j] = w_board_ret[i][j-1]+w_board_ret[i-1][j]+w_board[i][j]-w_board_ret[i-1][j-1]
            b_board_ret[i][j] = b_board_ret[i][j-1]+b_board_ret[i-1][j]+b_board[i][j]-b_board_ret[i-1][j-1]

min_cnt = 4000000
for i in range(N-K+1):
    for j in range(N-K+1):
        min_cnt = min(
            check_board(w_board_ret,i,j,i+K-1,j+K-1),
            check_board(b_board_ret,i,j,i+K-1,j+K-1),
            min_cnt
        )
print(min_cnt)
```

- Answer
```python

```

- Analyze
	-  그냥 w_board와 b_board 두 개의 2차 배열을 가지고 색칠해야하는 값에다가 1을 넣어주었다. 이후, x,y의 누적 합을 통해 count를 진행해 주었다. 다만, 3번째 예제가 틀렸다. 좀 더 확인해 보자.
### 알고리즘 분류
- 