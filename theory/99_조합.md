## 이항계수
![[Pasted image 20251013225552.png]]
이항계수란 주어진 집합에서 원하는 개수만큼 순서없이 뽑는 조합의 개수를 의미
`이항` 이란 한 개의 아이템에 대해서 `뽑거나` `뽑지않거나` 두 가지의 선택이 있기 때문에 붙은 단어
순서 상관 X

### 성질
![[Pasted image 20251014233056.png]]
1. n개중 k를 선택하는 조합의 수는 결국 n개 중 선택받지 못한 아이템들의 조합의 수와 같다.
	- $_nC_k$ = $_nC_{n-_r}$
2. 이항계수의 정의를 이용하여 도출된 식
	-  $_nC_k$ = $_{n-1}C_k$ + $_{n-1}C_{k-1}$ 
	- 파스칼의 항등식
		```
		ex) n명의 학생 중, k명의 반장을 뽑는다고 했을 때, 두 가지 경우의 수로 나뉜다.
		    1. a(특정 학생)이 뽑히지 않는 경우
		       n-1 명의 학생 중, k를 뽑아야한다.
		    2. a(특정 학생)이 뽑히는 경우
		       n-1 명의 학생 중, k-1를 뽑아야한다.
		```
		
3. 파스칼의 삼각형과 관련이 깊다.
### 알고리즘 구현
이항계수의 정의를 이용한 구현법 (math 사용)
```python
import math

def bino_coef_factorial(n, k):
	return math.factorial(n)// (math.factorial(n-k) * math.factorial(k))
```
이항계수의 성질을 이용한 구현법 (DP)
- 3번 성질에 따르면 이항계수는 그보다 작은 두 개의 부분식으로 쪼갤 수 있고, 쪼개진 부분식들은 그보다 작은 식으로 계속하여 쪼개질 수 있다.
![[Pasted image 20251014233325.png]]
- 또한 2번 성질에 의해서 전체에서 아무것도 선택하지 않는 조합 개수와 모든 아이템을 선택했을 때의 조합 개수는 1이라는 것을 알 수 있는데, 이는 부분식들을 쪼개다가 k가 0이 되거나 n과 k가 같으면 1이라는 것이다.
```python
# 위의 파스칼의 항등식으로 식들을 쪼개서 계산하는 식을 재귀함수로 표현하면
def bino_coef(n, k):
    if k == 0 or n == k:
        return 1
    return bino_coef(n-1, k) + bino_coef(n-1, k-1)
```
- 문제점은 같은 부분함수가 여러번 실행 된다.
	- bino_coef(n-1, k) + bino_coef(n-1, k-1)
	- (bino_coef(n-2, k) + bino_coef(n-2, k-2)) + (bino_coef(n-2, k-1) + bino_coef(n-2, k-2))
	- => bino_coef(n-2, k-2)) 중복
```python
# 한 번 계산한 값은 캐쉬에 저장해가며 풀기
def bino_coef(n, r):
    # 1.
    cache = [[0 for _ in range(r+1)] for _ in range(n+1)]

    # 2.
    for i in range(n+1):
        cache[i][0] = 1
    for i in range(r+1):
        cache[i][i] = 1

    # 3.
    for i in range(1, n+1):
        for j in range(1, r+1):
            cache[i][j] = cache[i-1][j] + cache[i-1][j-1]

    return cache[n][r]
```
1. 부분 문제 계산 시에 n의 범위는 0부터 n, k는 0부터 k까지의 범위를 가지기 때문에 `(n+1)(k+1)` 크기의 2차원 배열로 캐시를 초기화한다.
2. r이 0이 되거나 n과 r이 같은 경우는 1로 값을 넣어준다.
3. 이항계수의 3번 성질을 이용하여 값을 구한다. i개 중 j개의 아이템을 선택하는 경우의 수는 그 보다 작은 두 값의 합이다.