## 이항계수
![[Pasted image 20251013225552.png]]
이항계수란 주어진 집합에서 원하는 개수만큼 순서없이 뽑는 조합의 개수를 의미
`이항` 이란 한 개의 아이템에 대해서 `뽑거나` `뽑지않거나` 두 가지의 선택이 있기 때문에 붙은 단어
순서 상관 X

### 성질
![[Pasted image 20251014233056.png]]
1. n개중 k를 선택하는 조합의 수는 결국 n개 중 선택받지 못한 아이템들의 조합의 수와 같다.
	- $_nC_k$ = $_nC_{n-_r}$
2. 이항계수의 정의를 이용하여 도출된 식
	-  $_nC_k$ = $_{n-1}C_k$ + $_{n-1}C_{k-1}$ 
	- 파스칼의 항등식
		```
		ex) n명의 학생 중, k명의 반장을 뽑는다고 했을 때, 두 가지 경우의 수로 나뉜다.
		    1. a(특정 학생)이 뽑히지 않는 경우
		       n-1 명의 학생 중, k를 뽑아야한다.
		    2. a(특정 학생)이 뽑히는 경우
		       n-1 명의 학생 중, k-1를 뽑아야한다.
		```
		
3. 파스칼의 삼각형과 관련이 깊다.
### 알고리즘 구현
##### 이항계수의 정의를 이용한 구현법 (math 사용)
```python
import math

def bino_coef_factorial(n, k):
	return math.factorial(n)// (math.factorial(n-k) * math.factorial(k))
```
##### 이항계수의 성질을 이용한 구현법 (DP)
- 3번 성질에 따르면 이항계수는 그보다 작은 두 개의 부분식으로 쪼갤 수 있고, 쪼개진 부분식들은 그보다 작은 식으로 계속하여 쪼개질 수 있다.
![[Pasted image 20251014233325.png]]
- 또한 2번 성질에 의해서 전체에서 아무것도 선택하지 않는 조합 개수와 모든 아이템을 선택했을 때의 조합 개수는 1이라는 것을 알 수 있는데, 이는 부분식들을 쪼개다가 k가 0이 되거나 n과 k가 같으면 1이라는 것이다.
```python
# 위의 파스칼의 항등식으로 식들을 쪼개서 계산하는 식을 재귀함수로 표현하면
def bino_coef(n, k):
    if k == 0 or n == k:
        return 1
    return bino_coef(n-1, k) + bino_coef(n-1, k-1)
```
- 문제점은 같은 부분함수가 여러번 실행 된다.
	- bino_coef(n-1, k) + bino_coef(n-1, k-1)
	- (bino_coef(n-2, k) + bino_coef(n-2, k-2)) + (bino_coef(n-2, k-1) + bino_coef(n-2, k-2))
	- => bino_coef(n-2, k-2)) 중복
```python
# 한 번 계산한 값은 캐쉬에 저장해가며 풀기
def bino_coef(n, r):
    # 1.
    cache = [[0 for _ in range(r+1)] for _ in range(n+1)]

    # 2.
    for i in range(n+1):
        cache[i][0] = 1
    for i in range(r+1):
        cache[i][i] = 1

    # 3.
    for i in range(1, n+1):
        for j in range(1, r+1):
            cache[i][j] = cache[i-1][j] + cache[i-1][j-1]

    return cache[n][r]
```
1. 부분 문제 계산 시에 n의 범위는 0부터 n, k는 0부터 k까지의 범위를 가지기 때문에 `(n+1)(k+1)` 크기의 2차원 배열로 캐시를 초기화한다.
2. r이 0이 되거나 n과 r이 같은 경우는 1로 값을 넣어준다.
3. 이항계수의 3번 성질을 이용하여 값을 구한다. i개 중 j개의 아이템을 선택하는 경우의 수는 그 보다 작은 두 값의 합이다.

##### 완전 탐색으로 구현
확장성이 높은 구현 방법으로 조합 뿐만 아니라 확률을 구할 때도 사용 가능한 방법이다.
```python
def bino_coef_prob(n, k):
    if k > n:
        return 0
    # 1.
    cache = [[-1 for _ in range(n+1)] for _ in range(n+1)]

    # 2.
    def choose(times, got):
        # 3.
        if times == n:
		return got >= k  

    # 4.
    if cache[times][got] != -1:
       return cache[times][got]  

    # 5.
    cache[times][got] = 0.5 * choose(times+1, got) + 0.5 * choose(times+1, got+1)
    return cache[times][got] 

    # 6.
    return choose(0, 0)
```
1. 캐시를 초기화해준다. 값을 계산을 했는지, 안했는지를 판단하기 위해 0이 아닌 -1로 초기화해주었다. k가 n보다 큰 경우에는 무조건 0이기 때문에 이와 구분하기 위해 -1로 초기화를 한다.
2. 이번에 선택할 수 있는 기회에서 선택을 할지, 말지를 결정하는 함수이다. 인자로는 그 동안의 기회를 나타내는 times 와, 그동안 선택한 품목의 개수인 got 을 받는다. 확실히 하자. 이 함수의 의미는 times 번 동안 got 개를 선택하는 조합의 개수가 아니라, times 번까지 got 개를 선택했을 때, 최종적으로 n 번의 기회를 소진 시에 선택한 개수가 k 가 되는 경우의 수를 반환하는 함수이다.
3. n 번의 선택을 마쳤다면, 함수를 종료시킨다. 이때, 그동안 선택된 개수가 문제에서 주어진 k 와 일치하면 n 개 중 k 를 선택했으므로 1을 반환하되, 값이 다르면 0을 반환한다.(세지 않는다)
4. 그 다음으로 캐쉬에 우리의 부분문제의 답이 저장되어 있으면 그 값을 반환한다. -1은 초기화 값으로 현재 값이 -1이라는 얘기는 이 위치의 값은 건드린 적이 없다는 것, 그러니까 이전에 계산하지 않았기 때문에 계산해야 된다는 뜻이다
5. 캐쉬에 값이 없었으므로 값을 실제로 계산한다. times 번까지 got 개를 선택했을 때, 최종적으로 n 번의 기회를 소진 시에 선택한 개수가 k 가 되는 경우의 수는 times+1 번째에 got 개가 선택되었을 때(이번에 선택하지 않았을 때)와 times+1 번째에 got+1 개가 선택된 경우의 수(이번에 선택했을 때)의 합이다.
6. 함수를 시작한다. 이제 시작이고 그동안 선택한 것도 없으므로 당연히 times 와 got 모두 0이 될 수밖에 없다. 함수가 계속 호출되고, 인자가 점점 커지며 결국 n 번째까지 이를 것이고 그때 선택한 개수가 k 인 경우만 합산해서 결과를 내놓는다.

이 구현 방식을 이용하면 확률을 구하는 함수로도 활용할 수 있다. 예를 들어 동전 n번을 던질 때 앞면이 k개가 나올 확률을 구한다고 할 때, 아래처럼 원식의 5번 부분을 살짝만 변형해주면 된다.

```python
cache[times][got] = 0.5 * choose(times+1, got) + 0.5 * choose(times+1, got+1)# 5.
```

동전 던지는 예제라고 한다면 동전을 던져서 앞이 나오는 확률, 뒤가 나오는 확률 모두 0.5이다. 그래서 각 경우의 수에 단위확률을 곱해줌으로써 두 기대값을 구하고 더해줌으로써 확률을 구할 수 있다.


- 코드가 이상해서 이해가 가지 않는다. times와 got은 갑자기 왜 튀어 나왔으며, 실제 동작을 시켜보려고 해도 에러가 난다. 무엇을 원한 것인지 비슷한 예제를 찾아보고 분석해보자.
```python
def bino_coef_prob(n, k):
    """
    n번 동전을 던져서 k번 이상 앞면이 나올 확률을 계산
    예시: 5번 동전을 던져서 3번 이상 앞면이 나올 확률
    - n=5 (총 시행 횟수)
    - k=3 (최소 앞면 개수)
    """
    if k > n:
        return 0  

    # 메모이제이션을 위한 캐시 (이미 계산된 값 저장)
    cache = [[-1 for _ in range(n+1)] for _ in range(n+1)]  

    def calculate_probability(remaining_tosses, heads_count):
        """
        remaining_tosses: 남은 동전 던지기 횟수
        heads_count: 현재까지 앞면이 나온 횟수
        """
        # 모든 동전을 다 던졌을 때
        if remaining_tosses == 0:
            return 1 if heads_count >= k else 0
  
        # 이미 계산된 값이 있으면 반환 (메모이제이션)
        if cache[remaining_tosses][heads_count] != -1:
            return cache[remaining_tosses][heads_count]  

        # 다음 동전이 뒷면일 확률(0.5) + 앞면일 확률(0.5)
        prob_tails = 0.5 * calculate_probability(remaining_tosses-1, heads_count)
        prob_heads = 0.5 * calculate_probability(remaining_tosses-1, heads_count+1)

        # 결과를 캐시에 저장
        cache[remaining_tosses][heads_count] = prob_tails + prob_heads
        return cache[remaining_tosses][heads_count]  

    # 0번 던진 상태, 0개 앞면에서 시작
    return calculate_probability(n, 0)
```